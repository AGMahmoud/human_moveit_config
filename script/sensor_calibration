#!/usr/bin/env python
from human_moveit_config.human_model import HumanModel
from sensor_link.sensor_calibrator2 import SensorCalibrator
from sensor_link.sensor_reader import SensorReader
import rospy
import rospkg
import json
import os
import sys
import tf


class Calibrator(object):
    def __init__(self):
        self.rospack = rospkg.RosPack()
        self.sensor_reader = SensorReader(False)
        self.sensor_calibr = SensorCalibrator()
        self.sensor_calibr.human = HumanModel()
        self.tfl = tf.TransformListener()
        self.skeleton_poses = {}
        rospy.sleep(1)
        self.initialize_poses()

    def initialize_poses(self):
        self.skeleton_poses["T"] = self.sensor_calibr.human.get_T_pose()
        self.skeleton_poses["N"] = self.sensor_calibr.human.get_N_pose()
        self.skeleton_poses["H"] = self.sensor_calibr.human.get_H_pose()

    def request_for_position(self, sensor, frames_list, pose_id):
        # modify the list of visible frames
        if frames_list is list:
            self.sensor_reader.sensor_frames[sensor] = frames_list
        while not rospy.is_shutdown():
            rospy.sleep(5)
            os.system('beep')
            # raw_input("User in T position, press <Enter> when ready...")
            if self.sensor_reader.update_skeleton(sensor, debug=True):
                rospy.loginfo("T pose recorded successfully")
                break
            else:
                rospy.logerr("Cannot calibrate, skeleton not visible")
        # extract skeleton corresponding to sensor
        skel = self.sensor_reader.get_skeleton(sensor)
        # save the recorded T pose
        skeleton_file = self.rospack.get_path("human_moveit_config") + '/tmp/' + pose_id + '_skeleton.json'
        # check already existing file
        if os.path.exists(skeleton_file):
            with open(skeleton_file) as data_file:
                skeletons = json.load(data_file)
        else:
            skeletons = {}
        # overwrite only new value
        skeletons[sensor] = skel
        with open(skeleton_file, 'w') as output_file:
            json.dump(skeletons, output_file, sort_keys=True, indent=4)
        # return the recorded skeleton
        return skel

    def read_pose_from_file(self, sensor, pose_id):
        skeleton_file = self.rospack.get_path("human_moveit_config") + '/tmp/' + pose_id + '_skeleton.json'
        with open(skeleton_file) as data_file:
            skeletons = json.load(data_file)
        return skeletons[sensor]

    def create_calibration_matrices(self, sensor, sensor_param, reset_pose=False):
        # read the config file with the selected frames
        frames_file = self.rospack.get_path("human_moveit_config") + '/config/frames_list.json'
        with open(frames_file) as data_file:
            data_frames = json.load(data_file)
        # check that parameter is correct
        if sensor_param not in data_frames[sensor].keys():
            rospy.logerr('Parameter unknown')
            sys.exit(1)
        frames_list = data_frames[sensor][sensor_param]
        record_poses = {}
        for key in self.skeleton_poses.keys():
            # record a new pose
            if reset_pose:
                record_poses[key] = self.request_for_position(sensor, frames_list, key)
            else:
                record_poses[key] = self.read_pose_from_file(sensor, key)
        # for recorded skeleton calibrate the transformation matrices
        dict_calibr = {}
        # get ground axis
        ref = self.sensor_reader.sensors_ref[sensor] + '_frame'
        base_pose = self.tfl.lookupTransform(ref, 'base', rospy.Time(0))
        q = base_pose[1]
        z = [2 * (q[0] * q[2] + q[1] * q[3]),
             2 * (q[1] * q[2] - q[0] * q[3]),
             1 - 2 * q[0] * q[0] - 2 * q[1] * q[1]]
        self.sensor_calibr.set_ground_axis(z)
        # if the file already exist load it to overwrite previous values
        calibration_file = self.rospack.get_path("human_moveit_config") + "/tmp/sensor_calibration.json"
        if os.path.exists(calibration_file):
            with open(calibration_file) as data_file:
                dict_calibr = json.load(data_file)
        # calibrate using optimization
        dict_calibr[sensor] = self.sensor_calibr.calibrate(record_poses,
                                                           self.skeleton_poses,
                                                           frames_list)
        # write the calibration file
        with open(calibration_file, 'w') as output_file:
            json.dump(dict_calibr, output_file, sort_keys=True, indent=4)


if __name__ == '__main__':
    rospy.init_node('sensor_calibrator')
    calibrator = Calibrator()
    # create calibration matrices from human model
    calibrator.create_calibration_matrices(sys.argv[1], sys.argv[2])
